//! A demonstration of an offchain worker that sends onchain callbacks

#![cfg_attr(not(feature = "std"), no_std)]

#[cfg(test)]
mod tests;

use core::{convert::TryInto, fmt};
use frame_support::{
	debug, decl_error, decl_event, decl_module, decl_storage, dispatch::DispatchResult,
};
use parity_scale_codec::{Decode, Encode};

use frame_system::{
	self as system, ensure_none, ensure_signed,
	offchain::{
		AppCrypto, CreateSignedTransaction, SendSignedTransaction, SendUnsignedTransaction,
		SignedPayload, SigningTypes, Signer, SubmitTransaction,
	},
};
use sp_core::crypto::KeyTypeId;
use sp_runtime::{
	RuntimeDebug,
	offchain as rt_offchain,
	offchain::{
		storage::StorageValueRef,
		storage_lock::{StorageLock, BlockAndTime},
	},
	transaction_validity::{
		InvalidTransaction, TransactionSource, TransactionValidity,
		ValidTransaction,
	},
};
use sp_std::{
	prelude::*, str,
	collections::vec_deque::VecDeque,
};
use uuid::{Builder, Uuid, Variant, Version};

// We use `alt_serde`, and Xanewok-modified `serde_json` so that we can compile the program
//   with serde(features `std`) and alt_serde(features `no_std`).
use alt_serde::{Deserialize, Deserializer};

pub const FETCH_TIMEOUT_PERIOD: u64 = 3000; // in milli-seconds

/// This is the pallet's configuration trait
pub trait Trait: system::Trait {
	/// The overarching dispatch call type.
	type Call: From<Call<Self>>;
	/// The overarching event type.
	type Event: From<Event<Self>> + Into<<Self as system::Trait>::Event>;
}

decl_storage! {
	trait Store for Module<T: Trait> as OCW {
		/// A vector of recently submitted numbers. Bounded by NUM_VEC_LEN
		Numbers get(fn numbers): VecDeque<u64>;

		Errand get(fn errand): u64;
	}
}

decl_event!(
	/// Events generated by the module.
	pub enum Event<T>
	where
		AccountId = <T as system::Trait>::AccountId,
	{
		/// Event generated when a new number is accepted to contribute to the average.
		NewNumber(Option<AccountId>, u64),
	}
);

decl_error! {
	pub enum Error for Module<T: Trait> {
		HttpPostingError,
	}
}

decl_module! {
	pub struct Module<T: Trait> for enum Call where origin: T::Origin {
		fn deposit_event() = default;

		#[weight = 10000]
		pub fn add_errrand(origin, number: u64) -> DispatchResult {
			Errand::set(number);
			Ok(())
		}

		fn offchain_worker(block_number: T::BlockNumber) {
			debug::info!("Entering off-chain worker");

		}
	}
}

impl<T: Trait> Module<T> {
	fn post_n_parse(errand_number: u128) -> Result<(), Error<T>> {
		let resp_bytes = Self::post_errand(errand_number).map_err(|e| {
			debug::error!("fetch_from_remote error: {:?}", e);
			<Error<T>>::HttpPostingError
		})?;

		let resp_str = str::from_utf8(&resp_bytes).map_err(|_| <Error<T>>::HttpPostingError)?;
		// Print out our fetched JSON string
		debug::info!("{}", resp_str);

		Ok(())
	}

	fn post_errand(errand_number: u128) -> Result<Vec<u8>, Error<T>> {
		let uuid = Builder::from_u128(errand_number)
			.set_variant(Variant::RFC4122)
			.set_version(Version::Random)
			.build();
		let mut buf = Uuid::encode_buffer();
		let uuid = uuid.to_hyphenated()
			.encode_lower(&mut buf);
		debug::info!("my_uuid {}", uuid);
		// let http_remote = format!(
		// 	"http://81.68.250.243:8000/api/service/5GBykvvrUz3vwTttgHzUEPdm7G1FND1reBfddQLdiaCbhoMd/{}/0x14fd87f46da9cd46750b93ba1aec47dc37ceb132dc97fa2b932bc9938a6cb9306a1fb070926ce9a3ade8ea6b49e51794741de6551daedf6ded090b94691d1c8b",
		// 	uuid);
		let http_remote = "http://81.68.250.243:8000/api/service/5GBykvvrUz3vwTttgHzUEPdm7G1FND1reBfddQLdiaCbhoMd/{}/0x14fd87f46da9cd46750b93ba1aec47dc37ceb132dc97fa2b932bc9938a6cb9306a1fb070926ce9a3ade8ea6b49e51794741de6551daedf6ded090b94691d1c8b";
		let post_body = vec![b""];

		// debug::info!("sending request to: {}", http_remote);

		// Initiate an external HTTP GET request. This is using high-level wrappers from `sp_runtime`.
		let request = rt_offchain::http::Request::post(&http_remote, post_body);

		// Keeping the offchain worker execution time reasonable, so limiting the call to be within 3s.
		let timeout = sp_io::offchain::timestamp()
			.add(rt_offchain::Duration::from_millis(FETCH_TIMEOUT_PERIOD));

		// For github API request, we also need to specify `user-agent` in http request header.
		//   See: https://developer.github.com/v3/#user-agent-required
		let pending = request
			.deadline(timeout) // Setting the timeout time
			.send() // Sending the request out by the host
			.map_err(|_| <Error<T>>::HttpPostingError)?;

		// By default, the http request is async from the runtime perspective. So we are asking the
		//   runtime to wait here.
		// The returning value here is a `Result` of `Result`, so we are unwrapping it twice by two `?`
		//   ref: https://substrate.dev/rustdocs/v2.0.0/sp_runtime/offchain/http/struct.PendingRequest.html#method.try_wait
		let response = pending
			.try_wait(timeout)
			.map_err(|_| <Error<T>>::HttpPostingError)?
			.map_err(|_| <Error<T>>::HttpPostingError)?;

		// if response.code != 200 {
		// 	debug::error!("Unexpected http request status code: {}", response.code);
		// 	return Err(<Error<T>>::HttpPostingError);
		// }

		// Next we fully read the response body and collect it to a vector of bytes.
		Ok(response.body().collect::<Vec<u8>>())
	}
}
